<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AIå¯¾æˆ¦ã‚ªã‚»ãƒ­ (æœ€çµ‚æ±ºæˆ¦ç‰ˆ)</title>
    <style>
        /* åŸºæœ¬è¨­å®š */
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
        }

        h1 {
            color: #333;
        }

        #message {
            font-size: 1.2em;
            margin: 10px 0;
            font-weight: bold;
        }

        /* ã‚ªã‚»ãƒ­ç›¤ã®è¨­å®š */
        #board-container {
            display: grid;
            grid-template-columns: repeat(8, 60px); 
            grid-template-rows: repeat(8, 60px);    
            width: 480px; 
            height: 480px;
            border: 3px solid #333;
            margin: 20px auto; 
            box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.5);
        }

        /* ãƒã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .cell {
            width: 60px;
            height: 60px;
            background-color: #008000;
            border: 1px solid #000;
            display: flex;
            justify-content: center; 
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        /* çŸ³ã®å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        .disc {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transition: background-color 0.3s ease; 
        }

        /* é»’ã„çŸ³ */
        .disc.black {
            background-color: black;
        }

        /* ç™½ã„çŸ³ */
        .disc.white {
            background-color: white;
        }

        /* ç½®ã‘ã‚‹ãƒã‚¹ã«ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º */
        .cell.hint::after {
            content: '';
            display: block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.6);
            position: absolute;
        }
    </style>
</head>
<body>
    <h1>AIå¯¾æˆ¦ã‚ªã‚»ãƒ­ (æœ€çµ‚æ±ºæˆ¦ç‰ˆ)</h1>
    
    <div id="message">ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ã‚ãªãŸã®ç•ªã§ã™ (é»’)</div>

    <div id="board-container"></div>
    
    <button id="reset-button">ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ</button>

    <script>
        // --- å®šæ•°ã¨å¤‰æ•° ---
        const EMPTY = 0;
        const BLACK = 1; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
        const WHITE = 2; // AI

        // ã€æœ€çµ‚èª¿æ•´æ¸ˆã¿ã®è©•ä¾¡ãƒ†ãƒ¼ãƒ–ãƒ«ã€‘
        const POSITION_WEIGHTS = [
            [ 100, -20,  10,  5,  5,  10, -20,  100], 
            [-20, -50,  -2, -2, -2,  -2, -50,  -20], 
            [ 10,  -2,  -1, -1, -1,  -1,  -2,   10],
            [  5,  -2,  -1,  0,  0,  -1,  -2,    5],
            [  5,  -2,  -1,  0,  0,  -1,  -2,    5],
            [ 10,  -2,  -1, -1, -1,  -1,  -2,   10],
            [-20, -50,  -2, -2, -2,  -2, -50,  -20],
            [ 100, -20,  10,  5,  5,  10, -20,  100]
        ];
        
        // ã€æœ€çµ‚èª¿æ•´æ¸ˆã¿ã®ã‚²ãƒ¼ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‘
        const MIDGAME_SEARCH_DEPTH = 6; // ä¸­ç›¤æˆ¦ã®æ¢ç´¢æ·±ã•
        const ENDGAME_THRESHOLD = 15;   // ç©ºããƒã‚¹ãŒ15ä»¥ä¸‹ã§å…¨æ¢ç´¢é–‹å§‹
        const MOBILITY_WEIGHT = 5;      
        const STABILITY_WEIGHT = 50;    // å®‰å®šæ€§è©•ä¾¡ã®é‡ã¿

        let board; 
        let currentPlayer;
        let isGameOver = false;
        const boardContainer = document.getElementById('board-container');
        const messageElement = document.getElementById('message');
        const resetButton = document.getElementById('reset-button');

        const DIRECTIONS = [
            [-1, 0], [1, 0], [0, -1], [0, 1], 
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ];

        // --- åŸºæœ¬é–¢æ•° ---

        function updateMessage(text) {
            messageElement.textContent = text;
        }

        function initGame() {
            board = [
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, WHITE, BLACK, 0, 0, 0],
                [0, 0, 0, BLACK, WHITE, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0]
            ];
            currentPlayer = BLACK;
            isGameOver = false;
            drawBoard();
            updateMessage("ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ã‚ãªãŸã®ç•ªã§ã™ (é»’)");
        }
        
        function getFlips(currentBoard, r, c, player) {
            if (currentBoard[r][c] !== EMPTY) return []; 
            const opponent = player === BLACK ? WHITE : BLACK;
            let flippedDiscs = [];
            for (const [dr, dc] of DIRECTIONS) {
                let currentFlips = [];
                let nr = r + dr;
                let nc = c + dc;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && currentBoard[nr][nc] === opponent) {
                    currentFlips.push({ row: nr, col: nc });
                    nr += dr;
                    nc += dc;
                }
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && currentBoard[nr][nc] === player) {
                    flippedDiscs.push(...currentFlips);
                }
            }
            return flippedDiscs;
        }

        function isValidMove(currentBoard, r, c, player) {
            return getFlips(currentBoard, r, c, player).length > 0;
        }

        function makeMove(currentBoard, r, c, player) {
            const flips = getFlips(currentBoard, r, c, player);
            currentBoard[r][c] = player;
            for (const { row, col } of flips) {
                currentBoard[row][col] = player;
            }
        }

        function getValidMoves(currentBoard, player) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === EMPTY && isValidMove(currentBoard, r, c, player)) {
                        moves.push({ row: r, col: c });
                    }
                }
            }
            return moves;
        }

        function countEmptyCells(currentBoard) {
            let emptyCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === EMPTY) emptyCount++;
                }
            }
            return emptyCount;
        }
        
        // --- AIãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹/è©•ä¾¡é–¢æ•°ï¼‰ ---
        
        function checkGameOverState(currentBoard) {
            const blackMoves = getValidMoves(currentBoard, BLACK).length;
            const whiteMoves = getValidMoves(currentBoard, WHITE).length;
            return blackMoves === 0 && whiteMoves === 0;
        }

        function finalScoreEvaluation(currentBoard) {
            let whiteCount = 0;
            let blackCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === WHITE) whiteCount++;
                    if (currentBoard[r][c] === BLACK) blackCount++;
                }
            }
            return (whiteCount - blackCount) * 100000; 
        }
        
        // ã€å®‰å®šæ€§è©•ä¾¡ã€‘è§’ã®ç¢ºå®šçŸ³ã‚’æ•°ãˆã‚‹
        function countStability(currentBoard, player) {
            let stabilityCount = 0;
            const corners = [[0, 0], [0, 7], [7, 0], [7, 7]];
            for (const [r, c] of corners) {
                if (currentBoard[r][c] === player) {
                    stabilityCount++;
                }
            }
            return stabilityCount;
        }


        /**
         * ã€æœ€çµ‚èª¿æ•´æ¸ˆã€‘ä¸­ç›¤æˆ¦ã®è©•ä¾¡é–¢æ•°ï¼ˆä½ç½® + ãƒ¢ãƒ“ãƒªãƒ†ã‚£ + å®‰å®šæ€§ + å‹•çš„é‡ã¿ï¼‰
         */
        function midgameEvaluation(currentBoard) {
            const emptyCells = countEmptyCells(currentBoard);
            
            let whiteScore = 0;
            let blackScore = 0;
            
            // 1. ä½ç½®è©•ä¾¡ (Placement Score)
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const weight = POSITION_WEIGHTS[r][c];
                    if (currentBoard[r][c] === WHITE) {
                        whiteScore += weight;
                    } else if (currentBoard[r][c] === BLACK) {
                        blackScore += weight;
                    }
                }
            }
            
            // 2. ãƒ¢ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡ (Mobility Score)
            const whiteMobility = getValidMoves(currentBoard, WHITE).length;
            const blackMobility = getValidMoves(currentBoard, BLACK).length;
            const mobilityScore = MOBILITY_WEIGHT * (whiteMobility - blackMobility);
            
            // 3. å®‰å®šæ€§è©•ä¾¡ (Stability Score)
            const stabilityScore = STABILITY_WEIGHT * (countStability(currentBoard, WHITE) - countStability(currentBoard, BLACK));
            
            // 4. ã€å‹•çš„é‡ã¿èª¿æ•´ã€‘ã‚²ãƒ¼ãƒ ã®é€²è¡Œåº¦ã§é‡ã¿ã‚’èª¿æ•´
            // åºç›¤(60)â†’çµ‚ç›¤(15)ã«è¿‘ã¥ãã«ã¤ã‚Œã¦çŸ³æ•°ã®ä¾¡å€¤ãŒä¸ŠãŒã‚‹
            const progress = (64 - emptyCells) / 64; 
            // ä½ç½®/çŸ³æ•°ã®é‡è¦åº¦ã‚’åºç›¤20%ã‹ã‚‰çµ‚ç›¤80%ã¸ç·šå½¢ã«å¢—åŠ 
            const dynamicWeight = 0.2 + (0.8 * progress); 


            // æœ€çµ‚ã‚¹ã‚³ã‚¢: (å‹•çš„çŸ³æ•°è©•ä¾¡) + (ãƒ¢ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡) + (å®‰å®šæ€§è©•ä¾¡)
            const placementScore = (whiteScore - blackScore) * dynamicWeight;
            
            return placementScore + mobilityScore + stabilityScore;
        }
        

        // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒ¼ã‚¿æåˆˆã‚Šä»˜ããƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹æ³•
        function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer) {
            const emptyCells = countEmptyCells(currentBoard);
            const isEndgame = emptyCells <= ENDGAME_THRESHOLD;

            // æ¢ç´¢çµ‚äº†æ¡ä»¶
            if (depth === 0 || checkGameOverState(currentBoard) || isEndgame) {
                if (checkGameOverState(currentBoard) || isEndgame) {
                     return finalScoreEvaluation(currentBoard);
                }
                return midgameEvaluation(currentBoard);
            }

            const player = isMaximizingPlayer ? WHITE : BLACK;
            const validMoves = getValidMoves(currentBoard, player);
            
            // ãƒ‘ã‚¹ã®å‡¦ç†
            if (validMoves.length === 0) {
                return minimax(currentBoard, depth - 1, alpha, beta, !isMaximizingPlayer);
            }

            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of validMoves) {
                    const newBoard = currentBoard.map(row => [...row]); 
                    makeMove(newBoard, move.row, move.col, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) break; 
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of validMoves) {
                    const newBoard = currentBoard.map(row => [...row]);
                    makeMove(newBoard, move.row, move.col, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) break; 
                }
                return minEval;
            }
        }

        // AIã®æœ€å–„æ‰‹ã‚’æ±ºå®šã™ã‚‹ãƒ¡ã‚¤ãƒ³é–¢æ•°
        function findAIBestMove(currentBoard) {
            const validMoves = getValidMoves(currentBoard, WHITE);
            if (validMoves.length === 0) return null;

            const emptyCells = countEmptyCells(currentBoard);
            const isEndgame = emptyCells <= ENDGAME_THRESHOLD;
            const depth = isEndgame ? emptyCells : MIDGAME_SEARCH_DEPTH;

            if(isEndgame) {
                updateMessage(`AI (ç™½) ã®æ€è€ƒä¸­ã§ã™...ã€çµ‚ç›¤ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆã‚µãƒ¼ãƒ: ${depth}æ‰‹èª­ã¿ã€‘`);
            } else {
                updateMessage(`AI (ç™½) ã®æ€è€ƒä¸­ã§ã™...ã€ä¸­ç›¤ç©¶æ¥µã‚µãƒ¼ãƒ: ${depth}æ‰‹èª­ã¿ã€‘`);
            }

            let bestMove = null;
            let maxEval = -Infinity;
            let alpha = -Infinity;
            const beta = Infinity;

            for (const move of validMoves) {
                const newBoard = currentBoard.map(row => [...row]);
                makeMove(newBoard, move.row, move.col, WHITE);

                const evaluation = minimax(newBoard, depth - 1, alpha, beta, false);

                if (evaluation > maxEval) {
                    maxEval = evaluation;
                    bestMove = move;
                }
                alpha = Math.max(alpha, maxEval);
            }
            return bestMove;
        }

        // --- æç”»ã¨ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ ---
        
        function drawBoard() {
            boardContainer.innerHTML = '';
            const validMoves = (!isGameOver && currentPlayer === BLACK) ? getValidMoves(board, BLACK) : [];

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', handleCellClick);

                    const isHint = validMoves.some(move => move.row === r && move.col === c);
                    if (isHint) {
                        cell.classList.add('hint');
                    }

                    if (board[r][c] !== EMPTY) {
                        const disc = document.createElement('div');
                        disc.classList.add('disc');
                        if (board[r][c] === BLACK) {
                            disc.classList.add('black');
                        } else if (board[r][c] === WHITE) {
                            disc.classList.add('white');
                        }
                        cell.appendChild(disc);
                    }
                    boardContainer.appendChild(cell);
                }
            }
        }

        function checkGameEnd() {
            const blackMoves = getValidMoves(board, BLACK).length;
            const whiteMoves = getValidMoves(board, WHITE).length;

            if (blackMoves === 0 && whiteMoves === 0) {
                isGameOver = true;
                let blackCount = 0;
                let whiteCount = 0;

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === BLACK) blackCount++;
                        if (board[r][c] === WHITE) whiteCount++;
                    }
                }

                let result = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼é»’: ${blackCount}ã€ç™½: ${whiteCount}ã€‚`;
                if (blackCount > whiteCount) {
                    result += "ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ğŸ‰";
                } else if (whiteCount > blackCount) {
                    result += "AIã®å‹ã¡ã§ã™ã€‚ğŸ¤–";
                } else {
                    result += "å¼•ãåˆ†ã‘ã§ã™ã€‚";
                }
                updateMessage(result);
                return true;
            }
            return false;
        }

        function runAI() {
            const validMoves = getValidMoves(board, WHITE);

            if (validMoves.length > 0) {
                const bestMove = findAIBestMove(board);

                makeMove(board, bestMove.row, bestMove.col, WHITE);
                
                if (checkGameEnd()) {
                    drawBoard();
                    return;
                }
                
                currentPlayer = BLACK;
                
                if (getValidMoves(board, BLACK).length > 0) {
                     updateMessage("ã‚ãªãŸã®ç•ªã§ã™ (é»’)");
                     drawBoard(); 
                } else {
                     updateMessage("ã‚ãªãŸã¯ãƒ‘ã‚¹ã§ã™ã€‚AIã®ç•ªãŒç¶šãã¾ã™ã€‚");
                     currentPlayer = WHITE;
                     setTimeout(runAI, 1000); 
                }
            } else {
                updateMessage("AIã¯ãƒ‘ã‚¹ã§ã™ã€‚ã‚ãªãŸã®ç•ªãŒç¶šãã¾ã™ (é»’)");
                currentPlayer = BLACK;
                
                if (getValidMoves(board, BLACK).length === 0) {
                    checkGameEnd();
                }
                
                drawBoard(); 
            }
        }

        function handleCellClick(event) {
            if (isGameOver || currentPlayer !== BLACK) {
                return;
            }

            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);

            if (isValidMove(board, row, col, BLACK)) {
                makeMove(board, row, col, BLACK);
                
                if (checkGameEnd()) {
                    drawBoard();
                    return;
                }
                
                currentPlayer = WHITE;
                
                drawBoard(); 

                // çµ‚ç›¤æˆ¦ã®è² è·ã‚’è€ƒæ…®ã—ã€æ€è€ƒæ™‚é–“ã¯é•·ã‚ã«è¨­å®šï¼ˆ1ç§’ï¼‰
                setTimeout(() => {
                    if (isGameOver) return;

                    if (getValidMoves(board, WHITE).length > 0) {
                        runAI();
                    } else {
                        updateMessage("AIã¯ãƒ‘ã‚¹ã§ã™ã€‚ã‚ãªãŸã®ç•ªãŒç¶šãã¾ã™ (é»’)");
                        currentPlayer = BLACK;

                        if (getValidMoves(board, BLACK).length === 0) {
                            checkGameEnd();
                        }
                        drawBoard();
                    }
                }, 1000); 

            } else {
                updateMessage("ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚ç™½ã„ç‚¹ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚");
            }
        }

        // --- åˆæœŸåŒ–ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        initGame();
        resetButton.addEventListener('click', initGame);
    </script>
</body>
</html>
